#### 1、CSS实现垂直居中

	HTML:
		
	<div class="wrapper">
		<div class="content"></div>
	</div>
	
		
	CSS:
	.wrapper{
		position: relative;
	}
	.content{
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate3d(-50%,-50%,0);
	}
	注：适用于未知标签宽高场景，如已经宽高则可无需transform，上下margin宽高的一半即可居中。
	



#### 2、标准盒子模型与IE盒子模型及其转换

标准盒子模型：margin + border + padding + content
IE盒子模型：margin + content（包含border和padding）

注：css中设置的width、height其实就是content的宽高，所以说在IE盒子中设置盒子宽度是包含padding和border的，举个栗子
	
	div {
		width:100px;
		height:100px;
		padding:10px;
		border:5px;
		magin:20px;
	}
	//标准盒子：在页面上占空间宽度为 100px+2*10px+2*5px+2*20px = 170px
	//IE盒子：在页面上占空间宽度为 100px+2*20px = 140px



转换：
	
	box-sizing: border-box;   //转换为IE盒子
	box-sizing: content-box;  //转换为标准盒子
	
	
#### 3、请罗列出所知道的display属性的值

	display: none;
	display: block;
	display: inline;
	display: inline-block;
	
	注：以上四个必须知道，及其代表的意义和区别，深入可问行内元素和块级元素、img标签、canvas标签等。
	
#### 4、两种方式实现div元素以50px每秒的速度左移100px

方法一：

	js实现动画 
	var left = $("div").offset().left;
	$("div").animate({left:left+100+'px'},2000);

方法二：

	css transition实现动画
	
	div{
		left: 0;
		transition: left 2s;
	}
	.animate{
		left: 100px;
	}

方法三：
 
	css animation实现动画
	
	@keyframes move
	{
		from {left: 0;}
		to {left: 100px;}
	}
	
	.animate{
		animation: move 2s;
	}
		
	

#### 5、用 DIV + CSS实现三栏布局（左右固定200px，中间自适应）
html:

	<div class="wrap">
		<div class="left"></div>	
		<div class="mid"></div>
		<div class="right"></div>
	</div>
	
css:
	
	.wrap{
		position:relative;
		padding: 0 200px;
	}
	.left, .right{
		postionn: absolute;
		top: 0;
		width: 200px;
	}
	.left{
		left: 0;
	}
	.right{
		right: 0;
	}
	
	
	
#### 1、描述一下变量的区别：null，undefined 或 undeclared？如何检测他们？

null: 空，未赋值

undefined: 缺少值，未赋值

undeclared: 未定义

使用typeof检测

区别：

- typeof(null)   =>  object

- typeof(undefined) => undefined




#### 2、解释下为什么接下来这段代码不是IIFE（立即调用的函数表达式）：function foo(){}()

function foo(){}()是函数声明，不是函数表达式，要想成为IIFE，必须是函数表达式。

可改为：!function foo(){}()、(function foo(){})()、var fn=function(){}()

#### 3、解释下面代码的功能
	
	Function.prototype.bind = function(){ 
  		var fn = this, 
  			args = Array.prototype.slice.call(arguments), 
  			object = args.shift(); 
  		return function(){ 
    		return fn.apply(object,args.concat(Array.prototype.slice.call(arguments))); 
  		}; 
	};
	
	
功能：为方法指定this指向，由于js中方法中this的指向需要根据方法执行时而定的，为了保持this的指向。

举个栗子：
	
	$('elem').on('click', function(){
		
		console.log(this);    //this指向 当前点击的elem
		
		setTimeout(function(){
			
			console.log(this); //this指向 window
			
		},0)
	
	})
	
如何要让setTimeout中也能访问到elem的话
	
方法a: 定义变量

	$('elem').on('click', function(){
		var t = this;
		setTimeout(function(){
			console.log(t); 
		},0)
	})
	
方法b：箭头函数

	$('elem').on('click', function(){
		var t = this;
		setTimeout( () => {
			console.log(this); 
		},0)
	})
	
方法c：Function.prototype.bind

	$('elem').on('click', function(){
		var t = this;
		setTimeout( () => {
			console.log(tthis); 
		},0).bind(this)
	})
	
#### 4、按顺序写出alert弹出窗口的内容
	
	var name = "The Window";
	var object = {
	      name : "My Object",
	      getNameFunc : function(){
	          alert('1.' + this.name);
	          return function(){
	              return this.name;
	          };
	      }
	};
	
	var func = object.getNameFunc();
	alert('2.' + func());
	alert('3.' + func.call(object));
	alert('4.' + func.apply(object));


输出：1.My Object
	 2.The Window
	 3.My Object
	 4.My Object
	 
注：考察this关键字、call及apply
	 
#### 5、JS里面new操作符具体干了什么
	
	var obj = new Base();
	
- 1、创建了一个空对象obj
- 2、obj的__proto__指向该实例对象的构造函数的原型对象
- 3、函数对象的this指针指向obj，调用构造函数
	
	
	
	
	
	
	
	